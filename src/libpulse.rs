use libc::*;
pub type Struct_timeval = timeval;

/* automatically generated by rust-bindgen */

pub type Enum_pa_sample_format = ::libc::c_int;
pub const PA_SAMPLE_U8: ::libc::c_int = 0;
pub const PA_SAMPLE_ALAW: ::libc::c_int = 1;
pub const PA_SAMPLE_ULAW: ::libc::c_int = 2;
pub const PA_SAMPLE_S16LE: ::libc::c_int = 3;
pub const PA_SAMPLE_S16BE: ::libc::c_int = 4;
pub const PA_SAMPLE_FLOAT32LE: ::libc::c_int = 5;
pub const PA_SAMPLE_FLOAT32BE: ::libc::c_int = 6;
pub const PA_SAMPLE_S32LE: ::libc::c_int = 7;
pub const PA_SAMPLE_S32BE: ::libc::c_int = 8;
pub const PA_SAMPLE_S24LE: ::libc::c_int = 9;
pub const PA_SAMPLE_S24BE: ::libc::c_int = 10;
pub const PA_SAMPLE_S24_32LE: ::libc::c_int = 11;
pub const PA_SAMPLE_S24_32BE: ::libc::c_int = 12;
pub const PA_SAMPLE_MAX: ::libc::c_int = 13;
pub const PA_SAMPLE_INVALID: ::libc::c_int = -1;
pub type pa_sample_format_t = Enum_pa_sample_format;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_sample_spec {
    pub format: pa_sample_format_t,
    pub rate: uint32_t,
    pub channels: uint8_t,
}
impl ::std::clone::Clone for Struct_pa_sample_spec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_sample_spec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_sample_spec = Struct_pa_sample_spec;
pub type pa_usec_t = uint64_t;
pub type Enum_pa_context_state = ::libc::c_uint;
pub const PA_CONTEXT_UNCONNECTED: ::libc::c_uint = 0;
pub const PA_CONTEXT_CONNECTING: ::libc::c_uint = 1;
pub const PA_CONTEXT_AUTHORIZING: ::libc::c_uint = 2;
pub const PA_CONTEXT_SETTING_NAME: ::libc::c_uint = 3;
pub const PA_CONTEXT_READY: ::libc::c_uint = 4;
pub const PA_CONTEXT_FAILED: ::libc::c_uint = 5;
pub const PA_CONTEXT_TERMINATED: ::libc::c_uint = 6;
pub type pa_context_state_t = Enum_pa_context_state;
pub type Enum_pa_stream_state = ::libc::c_uint;
pub const PA_STREAM_UNCONNECTED: ::libc::c_uint = 0;
pub const PA_STREAM_CREATING: ::libc::c_uint = 1;
pub const PA_STREAM_READY: ::libc::c_uint = 2;
pub const PA_STREAM_FAILED: ::libc::c_uint = 3;
pub const PA_STREAM_TERMINATED: ::libc::c_uint = 4;
pub type pa_stream_state_t = Enum_pa_stream_state;
pub type Enum_pa_operation_state = ::libc::c_uint;
pub const PA_OPERATION_RUNNING: ::libc::c_uint = 0;
pub const PA_OPERATION_DONE: ::libc::c_uint = 1;
pub const PA_OPERATION_CANCELLED: ::libc::c_uint = 2;
pub type pa_operation_state_t = Enum_pa_operation_state;
pub type Enum_pa_context_flags = ::libc::c_uint;
pub const PA_CONTEXT_NOFLAGS: ::libc::c_uint = 0;
pub const PA_CONTEXT_NOAUTOSPAWN: ::libc::c_uint = 1;
pub const PA_CONTEXT_NOFAIL: ::libc::c_uint = 2;
pub type pa_context_flags_t = Enum_pa_context_flags;
pub type Enum_pa_direction = ::libc::c_uint;
pub const PA_DIRECTION_OUTPUT: ::libc::c_uint = 1;
pub const PA_DIRECTION_INPUT: ::libc::c_uint = 2;
pub type pa_direction_t = Enum_pa_direction;
pub type Enum_pa_device_type = ::libc::c_uint;
pub const PA_DEVICE_TYPE_SINK: ::libc::c_uint = 0;
pub const PA_DEVICE_TYPE_SOURCE: ::libc::c_uint = 1;
pub type pa_device_type_t = Enum_pa_device_type;
pub type Enum_pa_stream_direction = ::libc::c_uint;
pub const PA_STREAM_NODIRECTION: ::libc::c_uint = 0;
pub const PA_STREAM_PLAYBACK: ::libc::c_uint = 1;
pub const PA_STREAM_RECORD: ::libc::c_uint = 2;
pub const PA_STREAM_UPLOAD: ::libc::c_uint = 3;
pub type pa_stream_direction_t = Enum_pa_stream_direction;
pub type Enum_pa_stream_flags = ::libc::c_uint;
pub const PA_STREAM_NOFLAGS: ::libc::c_uint = 0;
pub const PA_STREAM_START_CORKED: ::libc::c_uint = 1;
pub const PA_STREAM_INTERPOLATE_TIMING: ::libc::c_uint = 2;
pub const PA_STREAM_NOT_MONOTONIC: ::libc::c_uint = 4;
pub const PA_STREAM_AUTO_TIMING_UPDATE: ::libc::c_uint = 8;
pub const PA_STREAM_NO_REMAP_CHANNELS: ::libc::c_uint = 16;
pub const PA_STREAM_NO_REMIX_CHANNELS: ::libc::c_uint = 32;
pub const PA_STREAM_FIX_FORMAT: ::libc::c_uint = 64;
pub const PA_STREAM_FIX_RATE: ::libc::c_uint = 128;
pub const PA_STREAM_FIX_CHANNELS: ::libc::c_uint = 256;
pub const PA_STREAM_DONT_MOVE: ::libc::c_uint = 512;
pub const PA_STREAM_VARIABLE_RATE: ::libc::c_uint = 1024;
pub const PA_STREAM_PEAK_DETECT: ::libc::c_uint = 2048;
pub const PA_STREAM_START_MUTED: ::libc::c_uint = 4096;
pub const PA_STREAM_ADJUST_LATENCY: ::libc::c_uint = 8192;
pub const PA_STREAM_EARLY_REQUESTS: ::libc::c_uint = 16384;
pub const PA_STREAM_DONT_INHIBIT_AUTO_SUSPEND: ::libc::c_uint = 32768;
pub const PA_STREAM_START_UNMUTED: ::libc::c_uint = 65536;
pub const PA_STREAM_FAIL_ON_SUSPEND: ::libc::c_uint = 131072;
pub const PA_STREAM_RELATIVE_VOLUME: ::libc::c_uint = 262144;
pub const PA_STREAM_PASSTHROUGH: ::libc::c_uint = 524288;
pub type pa_stream_flags_t = Enum_pa_stream_flags;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_buffer_attr {
    pub maxlength: uint32_t,
    pub tlength: uint32_t,
    pub prebuf: uint32_t,
    pub minreq: uint32_t,
    pub fragsize: uint32_t,
}
impl ::std::clone::Clone for Struct_pa_buffer_attr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_buffer_attr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_buffer_attr = Struct_pa_buffer_attr;
pub type Enum_pa_error_code = ::libc::c_uint;
pub const PA_OK: ::libc::c_uint = 0;
pub const PA_ERR_ACCESS: ::libc::c_uint = 1;
pub const PA_ERR_COMMAND: ::libc::c_uint = 2;
pub const PA_ERR_INVALID: ::libc::c_uint = 3;
pub const PA_ERR_EXIST: ::libc::c_uint = 4;
pub const PA_ERR_NOENTITY: ::libc::c_uint = 5;
pub const PA_ERR_CONNECTIONREFUSED: ::libc::c_uint = 6;
pub const PA_ERR_PROTOCOL: ::libc::c_uint = 7;
pub const PA_ERR_TIMEOUT: ::libc::c_uint = 8;
pub const PA_ERR_AUTHKEY: ::libc::c_uint = 9;
pub const PA_ERR_INTERNAL: ::libc::c_uint = 10;
pub const PA_ERR_CONNECTIONTERMINATED: ::libc::c_uint = 11;
pub const PA_ERR_KILLED: ::libc::c_uint = 12;
pub const PA_ERR_INVALIDSERVER: ::libc::c_uint = 13;
pub const PA_ERR_MODINITFAILED: ::libc::c_uint = 14;
pub const PA_ERR_BADSTATE: ::libc::c_uint = 15;
pub const PA_ERR_NODATA: ::libc::c_uint = 16;
pub const PA_ERR_VERSION: ::libc::c_uint = 17;
pub const PA_ERR_TOOLARGE: ::libc::c_uint = 18;
pub const PA_ERR_NOTSUPPORTED: ::libc::c_uint = 19;
pub const PA_ERR_UNKNOWN: ::libc::c_uint = 20;
pub const PA_ERR_NOEXTENSION: ::libc::c_uint = 21;
pub const PA_ERR_OBSOLETE: ::libc::c_uint = 22;
pub const PA_ERR_NOTIMPLEMENTED: ::libc::c_uint = 23;
pub const PA_ERR_FORKED: ::libc::c_uint = 24;
pub const PA_ERR_IO: ::libc::c_uint = 25;
pub const PA_ERR_BUSY: ::libc::c_uint = 26;
pub const PA_ERR_MAX: ::libc::c_uint = 27;
pub type pa_error_code_t = Enum_pa_error_code;
pub type Enum_pa_subscription_mask = ::libc::c_uint;
pub const PA_SUBSCRIPTION_MASK_NULL: ::libc::c_uint = 0;
pub const PA_SUBSCRIPTION_MASK_SINK: ::libc::c_uint = 1;
pub const PA_SUBSCRIPTION_MASK_SOURCE: ::libc::c_uint = 2;
pub const PA_SUBSCRIPTION_MASK_SINK_INPUT: ::libc::c_uint = 4;
pub const PA_SUBSCRIPTION_MASK_SOURCE_OUTPUT: ::libc::c_uint = 8;
pub const PA_SUBSCRIPTION_MASK_MODULE: ::libc::c_uint = 16;
pub const PA_SUBSCRIPTION_MASK_CLIENT: ::libc::c_uint = 32;
pub const PA_SUBSCRIPTION_MASK_SAMPLE_CACHE: ::libc::c_uint = 64;
pub const PA_SUBSCRIPTION_MASK_SERVER: ::libc::c_uint = 128;
pub const PA_SUBSCRIPTION_MASK_AUTOLOAD: ::libc::c_uint = 256;
pub const PA_SUBSCRIPTION_MASK_CARD: ::libc::c_uint = 512;
pub const PA_SUBSCRIPTION_MASK_ALL: ::libc::c_uint = 767;
pub type pa_subscription_mask_t = Enum_pa_subscription_mask;
pub type Enum_pa_subscription_event_type = ::libc::c_uint;
pub const PA_SUBSCRIPTION_EVENT_SINK: ::libc::c_uint = 0;
pub const PA_SUBSCRIPTION_EVENT_SOURCE: ::libc::c_uint = 1;
pub const PA_SUBSCRIPTION_EVENT_SINK_INPUT: ::libc::c_uint = 2;
pub const PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT: ::libc::c_uint = 3;
pub const PA_SUBSCRIPTION_EVENT_MODULE: ::libc::c_uint = 4;
pub const PA_SUBSCRIPTION_EVENT_CLIENT: ::libc::c_uint = 5;
pub const PA_SUBSCRIPTION_EVENT_SAMPLE_CACHE: ::libc::c_uint = 6;
pub const PA_SUBSCRIPTION_EVENT_SERVER: ::libc::c_uint = 7;
pub const PA_SUBSCRIPTION_EVENT_AUTOLOAD: ::libc::c_uint = 8;
pub const PA_SUBSCRIPTION_EVENT_CARD: ::libc::c_uint = 9;
pub const PA_SUBSCRIPTION_EVENT_FACILITY_MASK: ::libc::c_uint = 15;
pub const PA_SUBSCRIPTION_EVENT_NEW: ::libc::c_uint = 0;
pub const PA_SUBSCRIPTION_EVENT_CHANGE: ::libc::c_uint = 16;
pub const PA_SUBSCRIPTION_EVENT_REMOVE: ::libc::c_uint = 32;
pub const PA_SUBSCRIPTION_EVENT_TYPE_MASK: ::libc::c_uint = 48;
pub type pa_subscription_event_type_t = Enum_pa_subscription_event_type;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_timing_info {
    pub timestamp: Struct_timeval,
    pub synchronized_clocks: ::libc::c_int,
    pub sink_usec: pa_usec_t,
    pub source_usec: pa_usec_t,
    pub transport_usec: pa_usec_t,
    pub playing: ::libc::c_int,
    pub write_index_corrupt: ::libc::c_int,
    pub write_index: int64_t,
    pub read_index_corrupt: ::libc::c_int,
    pub read_index: int64_t,
    pub configured_sink_usec: pa_usec_t,
    pub configured_source_usec: pa_usec_t,
    pub since_underrun: int64_t,
}
impl ::std::clone::Clone for Struct_pa_timing_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_timing_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_timing_info = Struct_pa_timing_info;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_spawn_api {
    pub prefork: ::std::option::Option<extern "C" fn() -> ()>,
    pub postfork: ::std::option::Option<extern "C" fn() -> ()>,
    pub atfork: ::std::option::Option<extern "C" fn() -> ()>,
}
impl ::std::clone::Clone for Struct_pa_spawn_api {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_spawn_api {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_spawn_api = Struct_pa_spawn_api;
pub type Enum_pa_seek_mode = ::libc::c_uint;
pub const PA_SEEK_RELATIVE: ::libc::c_uint = 0;
pub const PA_SEEK_ABSOLUTE: ::libc::c_uint = 1;
pub const PA_SEEK_RELATIVE_ON_READ: ::libc::c_uint = 2;
pub const PA_SEEK_RELATIVE_END: ::libc::c_uint = 3;
pub type pa_seek_mode_t = Enum_pa_seek_mode;
pub type Enum_pa_sink_flags = ::libc::c_uint;
pub const PA_SINK_NOFLAGS: ::libc::c_uint = 0;
pub const PA_SINK_HW_VOLUME_CTRL: ::libc::c_uint = 1;
pub const PA_SINK_LATENCY: ::libc::c_uint = 2;
pub const PA_SINK_HARDWARE: ::libc::c_uint = 4;
pub const PA_SINK_NETWORK: ::libc::c_uint = 8;
pub const PA_SINK_HW_MUTE_CTRL: ::libc::c_uint = 16;
pub const PA_SINK_DECIBEL_VOLUME: ::libc::c_uint = 32;
pub const PA_SINK_FLAT_VOLUME: ::libc::c_uint = 64;
pub const PA_SINK_DYNAMIC_LATENCY: ::libc::c_uint = 128;
pub const PA_SINK_SET_FORMATS: ::libc::c_uint = 256;
pub type pa_sink_flags_t = Enum_pa_sink_flags;
pub type Enum_pa_sink_state = ::libc::c_int;
pub const PA_SINK_INVALID_STATE: ::libc::c_int = -1;
pub const PA_SINK_RUNNING: ::libc::c_int = 0;
pub const PA_SINK_IDLE: ::libc::c_int = 1;
pub const PA_SINK_SUSPENDED: ::libc::c_int = 2;
pub const PA_SINK_INIT: ::libc::c_int = -2;
pub const PA_SINK_UNLINKED: ::libc::c_int = -3;
pub type pa_sink_state_t = Enum_pa_sink_state;
pub type Enum_pa_source_flags = ::libc::c_uint;
pub const PA_SOURCE_NOFLAGS: ::libc::c_uint = 0;
pub const PA_SOURCE_HW_VOLUME_CTRL: ::libc::c_uint = 1;
pub const PA_SOURCE_LATENCY: ::libc::c_uint = 2;
pub const PA_SOURCE_HARDWARE: ::libc::c_uint = 4;
pub const PA_SOURCE_NETWORK: ::libc::c_uint = 8;
pub const PA_SOURCE_HW_MUTE_CTRL: ::libc::c_uint = 16;
pub const PA_SOURCE_DECIBEL_VOLUME: ::libc::c_uint = 32;
pub const PA_SOURCE_DYNAMIC_LATENCY: ::libc::c_uint = 64;
pub const PA_SOURCE_FLAT_VOLUME: ::libc::c_uint = 128;
pub type pa_source_flags_t = Enum_pa_source_flags;
pub type Enum_pa_source_state = ::libc::c_int;
pub const PA_SOURCE_INVALID_STATE: ::libc::c_int = -1;
pub const PA_SOURCE_RUNNING: ::libc::c_int = 0;
pub const PA_SOURCE_IDLE: ::libc::c_int = 1;
pub const PA_SOURCE_SUSPENDED: ::libc::c_int = 2;
pub const PA_SOURCE_INIT: ::libc::c_int = -2;
pub const PA_SOURCE_UNLINKED: ::libc::c_int = -3;
pub type pa_source_state_t = Enum_pa_source_state;
pub type pa_free_cb_t =
    ::std::option::Option<unsafe extern "C" fn(p: *mut ::libc::c_void) -> ()>;
pub type Enum_pa_port_available = ::libc::c_uint;
pub const PA_PORT_AVAILABLE_UNKNOWN: ::libc::c_uint = 0;
pub const PA_PORT_AVAILABLE_NO: ::libc::c_uint = 1;
pub const PA_PORT_AVAILABLE_YES: ::libc::c_uint = 2;
pub type pa_port_available_t = Enum_pa_port_available;
pub type pa_mainloop_api = Struct_pa_mainloop_api;
pub type Enum_pa_io_event_flags = ::libc::c_uint;
pub const PA_IO_EVENT_NULL: ::libc::c_uint = 0;
pub const PA_IO_EVENT_INPUT: ::libc::c_uint = 1;
pub const PA_IO_EVENT_OUTPUT: ::libc::c_uint = 2;
pub const PA_IO_EVENT_HANGUP: ::libc::c_uint = 4;
pub const PA_IO_EVENT_ERROR: ::libc::c_uint = 8;
pub type pa_io_event_flags_t = Enum_pa_io_event_flags;
pub enum Struct_pa_io_event { }
pub type pa_io_event = Struct_pa_io_event;
pub type pa_io_event_cb_t =
    ::std::option::Option<unsafe extern "C" fn(ea: *mut pa_mainloop_api,
                                               e: *mut pa_io_event,
                                               fd: ::libc::c_int,
                                               events: pa_io_event_flags_t,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub type pa_io_event_destroy_cb_t =
    ::std::option::Option<unsafe extern "C" fn(a: *mut pa_mainloop_api,
                                               e: *mut pa_io_event,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub enum Struct_pa_time_event { }
pub type pa_time_event = Struct_pa_time_event;
pub type pa_time_event_cb_t =
    ::std::option::Option<unsafe extern "C" fn(a: *mut pa_mainloop_api,
                                               e: *mut pa_time_event,
                                               tv: *const Struct_timeval,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub type pa_time_event_destroy_cb_t =
    ::std::option::Option<unsafe extern "C" fn(a: *mut pa_mainloop_api,
                                               e: *mut pa_time_event,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub enum Struct_pa_defer_event { }
pub type pa_defer_event = Struct_pa_defer_event;
pub type pa_defer_event_cb_t =
    ::std::option::Option<unsafe extern "C" fn(a: *mut pa_mainloop_api,
                                               e: *mut pa_defer_event,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub type pa_defer_event_destroy_cb_t =
    ::std::option::Option<unsafe extern "C" fn(a: *mut pa_mainloop_api,
                                               e: *mut pa_defer_event,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_mainloop_api {
    pub userdata: *mut ::libc::c_void,
    pub io_new: ::std::option::Option<unsafe extern "C" fn(a:
                                                               *mut pa_mainloop_api,
                                                           fd: ::libc::c_int,
                                                           events:
                                                               pa_io_event_flags_t,
                                                           cb:
                                                               pa_io_event_cb_t,
                                                           userdata:
                                                               *mut ::libc::c_void)
                                          -> *mut pa_io_event>,
    pub io_enable: ::std::option::Option<unsafe extern "C" fn(e:
                                                                  *mut pa_io_event,
                                                              events:
                                                                  pa_io_event_flags_t)
                                             -> ()>,
    pub io_free: ::std::option::Option<unsafe extern "C" fn(e:
                                                                *mut pa_io_event)
                                           -> ()>,
    pub io_set_destroy: ::std::option::Option<unsafe extern "C" fn(e:
                                                                       *mut pa_io_event,
                                                                   cb:
                                                                       pa_io_event_destroy_cb_t)
                                                  -> ()>,
    pub time_new: ::std::option::Option<unsafe extern "C" fn(a:
                                                                 *mut pa_mainloop_api,
                                                             tv:
                                                                 *const Struct_timeval,
                                                             cb:
                                                                 pa_time_event_cb_t,
                                                             userdata:
                                                                 *mut ::libc::c_void)
                                            -> *mut pa_time_event>,
    pub time_restart: ::std::option::Option<unsafe extern "C" fn(e:
                                                                     *mut pa_time_event,
                                                                 tv:
                                                                     *const Struct_timeval)
                                                -> ()>,
    pub time_free: ::std::option::Option<unsafe extern "C" fn(e:
                                                                  *mut pa_time_event)
                                             -> ()>,
    pub time_set_destroy: ::std::option::Option<unsafe extern "C" fn(e:
                                                                         *mut pa_time_event,
                                                                     cb:
                                                                         pa_time_event_destroy_cb_t)
                                                    -> ()>,
    pub defer_new: ::std::option::Option<unsafe extern "C" fn(a:
                                                                  *mut pa_mainloop_api,
                                                              cb:
                                                                  pa_defer_event_cb_t,
                                                              userdata:
                                                                  *mut ::libc::c_void)
                                             -> *mut pa_defer_event>,
    pub defer_enable: ::std::option::Option<unsafe extern "C" fn(e:
                                                                     *mut pa_defer_event,
                                                                 b:
                                                                     ::libc::c_int)
                                                -> ()>,
    pub defer_free: ::std::option::Option<unsafe extern "C" fn(e:
                                                                   *mut pa_defer_event)
                                              -> ()>,
    pub defer_set_destroy: ::std::option::Option<unsafe extern "C" fn(e:
                                                                          *mut pa_defer_event,
                                                                      cb:
                                                                          pa_defer_event_destroy_cb_t)
                                                     -> ()>,
    pub quit: ::std::option::Option<unsafe extern "C" fn(a:
                                                             *mut pa_mainloop_api,
                                                         retval:
                                                             ::libc::c_int)
                                        -> ()>,
}
impl ::std::clone::Clone for Struct_pa_mainloop_api {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_mainloop_api {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_pa_proplist { }
pub type pa_proplist = Struct_pa_proplist;
pub type Enum_pa_update_mode = ::libc::c_uint;
pub const PA_UPDATE_SET: ::libc::c_uint = 0;
pub const PA_UPDATE_MERGE: ::libc::c_uint = 1;
pub const PA_UPDATE_REPLACE: ::libc::c_uint = 2;
pub type pa_update_mode_t = Enum_pa_update_mode;
pub type Enum_pa_channel_position = ::libc::c_int;
pub const PA_CHANNEL_POSITION_INVALID: ::libc::c_int = -1;
pub const PA_CHANNEL_POSITION_MONO: ::libc::c_int = 0;
pub const PA_CHANNEL_POSITION_FRONT_LEFT: ::libc::c_int = 1;
pub const PA_CHANNEL_POSITION_FRONT_RIGHT: ::libc::c_int = 2;
pub const PA_CHANNEL_POSITION_FRONT_CENTER: ::libc::c_int = 3;
pub const PA_CHANNEL_POSITION_LEFT: ::libc::c_int = 1;
pub const PA_CHANNEL_POSITION_RIGHT: ::libc::c_int = 2;
pub const PA_CHANNEL_POSITION_CENTER: ::libc::c_int = 3;
pub const PA_CHANNEL_POSITION_REAR_CENTER: ::libc::c_int = 4;
pub const PA_CHANNEL_POSITION_REAR_LEFT: ::libc::c_int = 5;
pub const PA_CHANNEL_POSITION_REAR_RIGHT: ::libc::c_int = 6;
pub const PA_CHANNEL_POSITION_LFE: ::libc::c_int = 7;
pub const PA_CHANNEL_POSITION_SUBWOOFER: ::libc::c_int = 7;
pub const PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER: ::libc::c_int = 8;
pub const PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER: ::libc::c_int = 9;
pub const PA_CHANNEL_POSITION_SIDE_LEFT: ::libc::c_int = 10;
pub const PA_CHANNEL_POSITION_SIDE_RIGHT: ::libc::c_int = 11;
pub const PA_CHANNEL_POSITION_AUX0: ::libc::c_int = 12;
pub const PA_CHANNEL_POSITION_AUX1: ::libc::c_int = 13;
pub const PA_CHANNEL_POSITION_AUX2: ::libc::c_int = 14;
pub const PA_CHANNEL_POSITION_AUX3: ::libc::c_int = 15;
pub const PA_CHANNEL_POSITION_AUX4: ::libc::c_int = 16;
pub const PA_CHANNEL_POSITION_AUX5: ::libc::c_int = 17;
pub const PA_CHANNEL_POSITION_AUX6: ::libc::c_int = 18;
pub const PA_CHANNEL_POSITION_AUX7: ::libc::c_int = 19;
pub const PA_CHANNEL_POSITION_AUX8: ::libc::c_int = 20;
pub const PA_CHANNEL_POSITION_AUX9: ::libc::c_int = 21;
pub const PA_CHANNEL_POSITION_AUX10: ::libc::c_int = 22;
pub const PA_CHANNEL_POSITION_AUX11: ::libc::c_int = 23;
pub const PA_CHANNEL_POSITION_AUX12: ::libc::c_int = 24;
pub const PA_CHANNEL_POSITION_AUX13: ::libc::c_int = 25;
pub const PA_CHANNEL_POSITION_AUX14: ::libc::c_int = 26;
pub const PA_CHANNEL_POSITION_AUX15: ::libc::c_int = 27;
pub const PA_CHANNEL_POSITION_AUX16: ::libc::c_int = 28;
pub const PA_CHANNEL_POSITION_AUX17: ::libc::c_int = 29;
pub const PA_CHANNEL_POSITION_AUX18: ::libc::c_int = 30;
pub const PA_CHANNEL_POSITION_AUX19: ::libc::c_int = 31;
pub const PA_CHANNEL_POSITION_AUX20: ::libc::c_int = 32;
pub const PA_CHANNEL_POSITION_AUX21: ::libc::c_int = 33;
pub const PA_CHANNEL_POSITION_AUX22: ::libc::c_int = 34;
pub const PA_CHANNEL_POSITION_AUX23: ::libc::c_int = 35;
pub const PA_CHANNEL_POSITION_AUX24: ::libc::c_int = 36;
pub const PA_CHANNEL_POSITION_AUX25: ::libc::c_int = 37;
pub const PA_CHANNEL_POSITION_AUX26: ::libc::c_int = 38;
pub const PA_CHANNEL_POSITION_AUX27: ::libc::c_int = 39;
pub const PA_CHANNEL_POSITION_AUX28: ::libc::c_int = 40;
pub const PA_CHANNEL_POSITION_AUX29: ::libc::c_int = 41;
pub const PA_CHANNEL_POSITION_AUX30: ::libc::c_int = 42;
pub const PA_CHANNEL_POSITION_AUX31: ::libc::c_int = 43;
pub const PA_CHANNEL_POSITION_TOP_CENTER: ::libc::c_int = 44;
pub const PA_CHANNEL_POSITION_TOP_FRONT_LEFT: ::libc::c_int = 45;
pub const PA_CHANNEL_POSITION_TOP_FRONT_RIGHT: ::libc::c_int = 46;
pub const PA_CHANNEL_POSITION_TOP_FRONT_CENTER: ::libc::c_int = 47;
pub const PA_CHANNEL_POSITION_TOP_REAR_LEFT: ::libc::c_int = 48;
pub const PA_CHANNEL_POSITION_TOP_REAR_RIGHT: ::libc::c_int = 49;
pub const PA_CHANNEL_POSITION_TOP_REAR_CENTER: ::libc::c_int = 50;
pub const PA_CHANNEL_POSITION_MAX: ::libc::c_int = 51;
pub type pa_channel_position_t = Enum_pa_channel_position;
pub type pa_channel_position_mask_t = uint64_t;
pub type Enum_pa_channel_map_def = ::libc::c_uint;
pub const PA_CHANNEL_MAP_AIFF: ::libc::c_uint = 0;
pub const PA_CHANNEL_MAP_ALSA: ::libc::c_uint = 1;
pub const PA_CHANNEL_MAP_AUX: ::libc::c_uint = 2;
pub const PA_CHANNEL_MAP_WAVEEX: ::libc::c_uint = 3;
pub const PA_CHANNEL_MAP_OSS: ::libc::c_uint = 4;
pub const PA_CHANNEL_MAP_DEF_MAX: ::libc::c_uint = 5;
pub const PA_CHANNEL_MAP_DEFAULT: ::libc::c_uint = 0;
pub type pa_channel_map_def_t = Enum_pa_channel_map_def;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_channel_map {
    pub channels: uint8_t,
    pub map: [pa_channel_position_t; 32usize],
}
impl ::std::clone::Clone for Struct_pa_channel_map {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_channel_map {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_channel_map = Struct_pa_channel_map;
pub type Enum_pa_encoding = ::libc::c_int;
pub const PA_ENCODING_ANY: ::libc::c_int = 0;
pub const PA_ENCODING_PCM: ::libc::c_int = 1;
pub const PA_ENCODING_AC3_IEC61937: ::libc::c_int = 2;
pub const PA_ENCODING_EAC3_IEC61937: ::libc::c_int = 3;
pub const PA_ENCODING_MPEG_IEC61937: ::libc::c_int = 4;
pub const PA_ENCODING_DTS_IEC61937: ::libc::c_int = 5;
pub const PA_ENCODING_MPEG2_AAC_IEC61937: ::libc::c_int = 6;
pub const PA_ENCODING_MAX: ::libc::c_int = 7;
pub const PA_ENCODING_INVALID: ::libc::c_int = -1;
pub type pa_encoding_t = Enum_pa_encoding;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_format_info {
    pub encoding: pa_encoding_t,
    pub plist: *mut pa_proplist,
}
impl ::std::clone::Clone for Struct_pa_format_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_format_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_format_info = Struct_pa_format_info;
pub type Enum_pa_prop_type_t = ::libc::c_int;
pub const PA_PROP_TYPE_INT: ::libc::c_int = 0;
pub const PA_PROP_TYPE_INT_RANGE: ::libc::c_int = 1;
pub const PA_PROP_TYPE_INT_ARRAY: ::libc::c_int = 2;
pub const PA_PROP_TYPE_STRING: ::libc::c_int = 3;
pub const PA_PROP_TYPE_STRING_ARRAY: ::libc::c_int = 4;
pub const PA_PROP_TYPE_INVALID: ::libc::c_int = -1;
pub type pa_prop_type_t = Enum_pa_prop_type_t;
pub enum Struct_pa_operation { }
pub type pa_operation = Struct_pa_operation;
pub type pa_operation_notify_cb_t =
    ::std::option::Option<unsafe extern "C" fn(o: *mut pa_operation,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub enum Struct_pa_context { }
pub type pa_context = Struct_pa_context;
pub type pa_context_notify_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub type pa_context_success_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               success: ::libc::c_int,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub type pa_context_event_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               name: *const ::libc::c_char,
                                               p: *mut pa_proplist,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub type pa_volume_t = uint32_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_cvolume {
    pub channels: uint8_t,
    pub values: [pa_volume_t; 32usize],
}
impl ::std::clone::Clone for Struct_pa_cvolume {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_cvolume {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_cvolume = Struct_pa_cvolume;
pub enum Struct_pa_stream { }
pub type pa_stream = Struct_pa_stream;
pub type pa_stream_success_cb_t =
    ::std::option::Option<unsafe extern "C" fn(s: *mut pa_stream,
                                               success: ::libc::c_int,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub type pa_stream_request_cb_t =
    ::std::option::Option<unsafe extern "C" fn(p: *mut pa_stream,
                                               nbytes: size_t,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub type pa_stream_notify_cb_t =
    ::std::option::Option<unsafe extern "C" fn(p: *mut pa_stream,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub type pa_stream_event_cb_t =
    ::std::option::Option<unsafe extern "C" fn(p: *mut pa_stream,
                                               name: *const ::libc::c_char,
                                               pl: *mut pa_proplist,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_sink_port_info {
    pub name: *const ::libc::c_char,
    pub description: *const ::libc::c_char,
    pub priority: uint32_t,
    pub available: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_pa_sink_port_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_sink_port_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_sink_port_info = Struct_pa_sink_port_info;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_sink_info {
    pub name: *const ::libc::c_char,
    pub index: uint32_t,
    pub description: *const ::libc::c_char,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub owner_module: uint32_t,
    pub volume: pa_cvolume,
    pub mute: ::libc::c_int,
    pub monitor_source: uint32_t,
    pub monitor_source_name: *const ::libc::c_char,
    pub latency: pa_usec_t,
    pub driver: *const ::libc::c_char,
    pub flags: pa_sink_flags_t,
    pub proplist: *mut pa_proplist,
    pub configured_latency: pa_usec_t,
    pub base_volume: pa_volume_t,
    pub state: pa_sink_state_t,
    pub n_volume_steps: uint32_t,
    pub card: uint32_t,
    pub n_ports: uint32_t,
    pub ports: *mut *mut pa_sink_port_info,
    pub active_port: *mut pa_sink_port_info,
    pub n_formats: uint8_t,
    pub formats: *mut *mut pa_format_info,
}
impl ::std::clone::Clone for Struct_pa_sink_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_sink_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_sink_info = Struct_pa_sink_info;
pub type pa_sink_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_sink_info,
                                               eol: ::libc::c_int,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_source_port_info {
    pub name: *const ::libc::c_char,
    pub description: *const ::libc::c_char,
    pub priority: uint32_t,
    pub available: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_pa_source_port_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_source_port_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_source_port_info = Struct_pa_source_port_info;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_source_info {
    pub name: *const ::libc::c_char,
    pub index: uint32_t,
    pub description: *const ::libc::c_char,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub owner_module: uint32_t,
    pub volume: pa_cvolume,
    pub mute: ::libc::c_int,
    pub monitor_of_sink: uint32_t,
    pub monitor_of_sink_name: *const ::libc::c_char,
    pub latency: pa_usec_t,
    pub driver: *const ::libc::c_char,
    pub flags: pa_source_flags_t,
    pub proplist: *mut pa_proplist,
    pub configured_latency: pa_usec_t,
    pub base_volume: pa_volume_t,
    pub state: pa_source_state_t,
    pub n_volume_steps: uint32_t,
    pub card: uint32_t,
    pub n_ports: uint32_t,
    pub ports: *mut *mut pa_source_port_info,
    pub active_port: *mut pa_source_port_info,
    pub n_formats: uint8_t,
    pub formats: *mut *mut pa_format_info,
}
impl ::std::clone::Clone for Struct_pa_source_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_source_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_source_info = Struct_pa_source_info;
pub type pa_source_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_source_info,
                                               eol: ::libc::c_int,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_server_info {
    pub user_name: *const ::libc::c_char,
    pub host_name: *const ::libc::c_char,
    pub server_version: *const ::libc::c_char,
    pub server_name: *const ::libc::c_char,
    pub sample_spec: pa_sample_spec,
    pub default_sink_name: *const ::libc::c_char,
    pub default_source_name: *const ::libc::c_char,
    pub cookie: uint32_t,
    pub channel_map: pa_channel_map,
}
impl ::std::clone::Clone for Struct_pa_server_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_server_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_server_info = Struct_pa_server_info;
pub type pa_server_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_server_info,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_module_info {
    pub index: uint32_t,
    pub name: *const ::libc::c_char,
    pub argument: *const ::libc::c_char,
    pub n_used: uint32_t,
    pub auto_unload: ::libc::c_int,
    pub proplist: *mut pa_proplist,
}
impl ::std::clone::Clone for Struct_pa_module_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_module_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_module_info = Struct_pa_module_info;
pub type pa_module_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_module_info,
                                               eol: ::libc::c_int,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub type pa_context_index_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               idx: uint32_t,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_client_info {
    pub index: uint32_t,
    pub name: *const ::libc::c_char,
    pub owner_module: uint32_t,
    pub driver: *const ::libc::c_char,
    pub proplist: *mut pa_proplist,
}
impl ::std::clone::Clone for Struct_pa_client_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_client_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_client_info = Struct_pa_client_info;
pub type pa_client_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_client_info,
                                               eol: ::libc::c_int,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_card_profile_info {
    pub name: *const ::libc::c_char,
    pub description: *const ::libc::c_char,
    pub n_sinks: uint32_t,
    pub n_sources: uint32_t,
    pub priority: uint32_t,
}
impl ::std::clone::Clone for Struct_pa_card_profile_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_card_profile_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_card_profile_info = Struct_pa_card_profile_info;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_card_profile_info2 {
    pub name: *const ::libc::c_char,
    pub description: *const ::libc::c_char,
    pub n_sinks: uint32_t,
    pub n_sources: uint32_t,
    pub priority: uint32_t,
    pub available: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_pa_card_profile_info2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_card_profile_info2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_card_profile_info2 = Struct_pa_card_profile_info2;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_card_port_info {
    pub name: *const ::libc::c_char,
    pub description: *const ::libc::c_char,
    pub priority: uint32_t,
    pub available: ::libc::c_int,
    pub direction: ::libc::c_int,
    pub n_profiles: uint32_t,
    pub profiles: *mut *mut pa_card_profile_info,
    pub proplist: *mut pa_proplist,
    pub latency_offset: int64_t,
    pub profiles2: *mut *mut pa_card_profile_info2,
}
impl ::std::clone::Clone for Struct_pa_card_port_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_card_port_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_card_port_info = Struct_pa_card_port_info;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_card_info {
    pub index: uint32_t,
    pub name: *const ::libc::c_char,
    pub owner_module: uint32_t,
    pub driver: *const ::libc::c_char,
    pub n_profiles: uint32_t,
    pub profiles: *mut pa_card_profile_info,
    pub active_profile: *mut pa_card_profile_info,
    pub proplist: *mut pa_proplist,
    pub n_ports: uint32_t,
    pub ports: *mut *mut pa_card_port_info,
    pub profiles2: *mut *mut pa_card_profile_info2,
    pub active_profile2: *mut pa_card_profile_info2,
}
impl ::std::clone::Clone for Struct_pa_card_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_card_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_card_info = Struct_pa_card_info;
pub type pa_card_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_card_info,
                                               eol: ::libc::c_int,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_sink_input_info {
    pub index: uint32_t,
    pub name: *const ::libc::c_char,
    pub owner_module: uint32_t,
    pub client: uint32_t,
    pub sink: uint32_t,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub volume: pa_cvolume,
    pub buffer_usec: pa_usec_t,
    pub sink_usec: pa_usec_t,
    pub resample_method: *const ::libc::c_char,
    pub driver: *const ::libc::c_char,
    pub mute: ::libc::c_int,
    pub proplist: *mut pa_proplist,
    pub corked: ::libc::c_int,
    pub has_volume: ::libc::c_int,
    pub volume_writable: ::libc::c_int,
    pub format: *mut pa_format_info,
}
impl ::std::clone::Clone for Struct_pa_sink_input_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_sink_input_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_sink_input_info = Struct_pa_sink_input_info;
pub type pa_sink_input_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_sink_input_info,
                                               eol: ::libc::c_int,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_source_output_info {
    pub index: uint32_t,
    pub name: *const ::libc::c_char,
    pub owner_module: uint32_t,
    pub client: uint32_t,
    pub source: uint32_t,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub buffer_usec: pa_usec_t,
    pub source_usec: pa_usec_t,
    pub resample_method: *const ::libc::c_char,
    pub driver: *const ::libc::c_char,
    pub proplist: *mut pa_proplist,
    pub corked: ::libc::c_int,
    pub volume: pa_cvolume,
    pub mute: ::libc::c_int,
    pub has_volume: ::libc::c_int,
    pub volume_writable: ::libc::c_int,
    pub format: *mut pa_format_info,
}
impl ::std::clone::Clone for Struct_pa_source_output_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_source_output_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_source_output_info = Struct_pa_source_output_info;
pub type pa_source_output_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i:
                                                   *const pa_source_output_info,
                                               eol: ::libc::c_int,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_stat_info {
    pub memblock_total: uint32_t,
    pub memblock_total_size: uint32_t,
    pub memblock_allocated: uint32_t,
    pub memblock_allocated_size: uint32_t,
    pub scache_size: uint32_t,
}
impl ::std::clone::Clone for Struct_pa_stat_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_stat_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_stat_info = Struct_pa_stat_info;
pub type pa_stat_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_stat_info,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_sample_info {
    pub index: uint32_t,
    pub name: *const ::libc::c_char,
    pub volume: pa_cvolume,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub duration: pa_usec_t,
    pub bytes: uint32_t,
    pub lazy: ::libc::c_int,
    pub filename: *const ::libc::c_char,
    pub proplist: *mut pa_proplist,
}
impl ::std::clone::Clone for Struct_pa_sample_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_sample_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_sample_info = Struct_pa_sample_info;
pub type pa_sample_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_sample_info,
                                               eol: ::libc::c_int,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub type Enum_pa_autoload_type = ::libc::c_uint;
pub const PA_AUTOLOAD_SINK: ::libc::c_uint = 0;
pub const PA_AUTOLOAD_SOURCE: ::libc::c_uint = 1;
pub type pa_autoload_type_t = Enum_pa_autoload_type;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pa_autoload_info {
    pub index: uint32_t,
    pub name: *const ::libc::c_char,
    pub _type: pa_autoload_type_t,
    pub module: *const ::libc::c_char,
    pub argument: *const ::libc::c_char,
}
impl ::std::clone::Clone for Struct_pa_autoload_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pa_autoload_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pa_autoload_info = Struct_pa_autoload_info;
pub type pa_autoload_info_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               i: *const pa_autoload_info,
                                               eol: ::libc::c_int,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub type pa_context_subscribe_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               t:
                                                   pa_subscription_event_type_t,
                                               idx: uint32_t,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub type pa_context_play_sample_cb_t =
    ::std::option::Option<unsafe extern "C" fn(c: *mut pa_context,
                                               idx: uint32_t,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub enum Struct_pa_threaded_mainloop { }
pub type pa_threaded_mainloop = Struct_pa_threaded_mainloop;
pub enum Struct_pollfd { }
pub enum Struct_pa_mainloop { }
pub type pa_mainloop = Struct_pa_mainloop;
pub type pa_poll_func =
    ::std::option::Option<unsafe extern "C" fn(ufds: *mut Struct_pollfd,
                                               nfds: ::libc::c_ulong,
                                               timeout: ::libc::c_int,
                                               userdata: *mut ::libc::c_void)
                              -> ::libc::c_int>;
pub enum Struct_pa_signal_event { }
pub type pa_signal_event = Struct_pa_signal_event;
pub type pa_signal_cb_t =
    ::std::option::Option<unsafe extern "C" fn(api: *mut pa_mainloop_api,
                                               e: *mut pa_signal_event,
                                               sig: ::libc::c_int,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub type pa_signal_destroy_cb_t =
    ::std::option::Option<unsafe extern "C" fn(api: *mut pa_mainloop_api,
                                               e: *mut pa_signal_event,
                                               userdata: *mut ::libc::c_void)
                              -> ()>;
pub enum Struct_pa_simple { }
pub type pa_simple = Struct_pa_simple;
#[link(name = "pulse")]
extern "C" {
    pub fn pa_get_library_version() -> *const ::libc::c_char;
    pub fn pa_bytes_per_second(spec: *const pa_sample_spec) -> size_t;
    pub fn pa_frame_size(spec: *const pa_sample_spec) -> size_t;
    pub fn pa_sample_size(spec: *const pa_sample_spec) -> size_t;
    pub fn pa_sample_size_of_format(f: pa_sample_format_t) -> size_t;
    pub fn pa_bytes_to_usec(length: uint64_t, spec: *const pa_sample_spec)
     -> pa_usec_t;
    pub fn pa_usec_to_bytes(t: pa_usec_t, spec: *const pa_sample_spec)
     -> size_t;
    pub fn pa_sample_spec_init(spec: *mut pa_sample_spec)
     -> *mut pa_sample_spec;
    pub fn pa_sample_format_valid(format: ::libc::c_uint) -> ::libc::c_int;
    pub fn pa_sample_rate_valid(rate: uint32_t) -> ::libc::c_int;
    pub fn pa_channels_valid(channels: uint8_t) -> ::libc::c_int;
    pub fn pa_sample_spec_valid(spec: *const pa_sample_spec) -> ::libc::c_int;
    pub fn pa_sample_spec_equal(a: *const pa_sample_spec,
                                b: *const pa_sample_spec) -> ::libc::c_int;
    pub fn pa_sample_format_to_string(f: pa_sample_format_t)
     -> *const ::libc::c_char;
    pub fn pa_parse_sample_format(format: *const ::libc::c_char)
     -> pa_sample_format_t;
    pub fn pa_sample_spec_snprint(s: *mut ::libc::c_char, l: size_t,
                                  spec: *const pa_sample_spec)
     -> *mut ::libc::c_char;
    pub fn pa_bytes_snprint(s: *mut ::libc::c_char, l: size_t,
                            v: ::libc::c_uint) -> *mut ::libc::c_char;
    pub fn pa_sample_format_is_le(f: pa_sample_format_t) -> ::libc::c_int;
    pub fn pa_sample_format_is_be(f: pa_sample_format_t) -> ::libc::c_int;
    pub fn pa_direction_valid(direction: pa_direction_t) -> ::libc::c_int;
    pub fn pa_direction_to_string(direction: pa_direction_t)
     -> *const ::libc::c_char;
    pub fn pa_mainloop_api_once(m: *mut pa_mainloop_api,
                                callback:
                                    ::std::option::Option<unsafe extern "C" fn(m:
                                                                                   *mut pa_mainloop_api,
                                                                               userdata:
                                                                                   *mut ::libc::c_void)
                                                              -> ()>,
                                userdata: *mut ::libc::c_void) -> ();
    pub fn pa_proplist_new() -> *mut pa_proplist;
    pub fn pa_proplist_free(p: *mut pa_proplist) -> ();
    pub fn pa_proplist_key_valid(key: *const ::libc::c_char) -> ::libc::c_int;
    pub fn pa_proplist_sets(p: *mut pa_proplist, key: *const ::libc::c_char,
                            value: *const ::libc::c_char) -> ::libc::c_int;
    pub fn pa_proplist_setp(p: *mut pa_proplist, pair: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn pa_proplist_setf(p: *mut pa_proplist, key: *const ::libc::c_char,
                            format: *const ::libc::c_char, ...)
     -> ::libc::c_int;
    pub fn pa_proplist_set(p: *mut pa_proplist, key: *const ::libc::c_char,
                           data: *const ::libc::c_void, nbytes: size_t)
     -> ::libc::c_int;
    pub fn pa_proplist_gets(p: *mut pa_proplist, key: *const ::libc::c_char)
     -> *const ::libc::c_char;
    pub fn pa_proplist_get(p: *mut pa_proplist, key: *const ::libc::c_char,
                           data: *mut *const ::libc::c_void,
                           nbytes: *mut size_t) -> ::libc::c_int;
    pub fn pa_proplist_update(p: *mut pa_proplist, mode: pa_update_mode_t,
                              other: *const pa_proplist) -> ();
    pub fn pa_proplist_unset(p: *mut pa_proplist, key: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn pa_proplist_unset_many(p: *mut pa_proplist,
                                  keys: *const *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn pa_proplist_iterate(p: *mut pa_proplist,
                               state: *mut *mut ::libc::c_void)
     -> *const ::libc::c_char;
    pub fn pa_proplist_to_string(p: *mut pa_proplist) -> *mut ::libc::c_char;
    pub fn pa_proplist_to_string_sep(p: *mut pa_proplist,
                                     sep: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn pa_proplist_from_string(str: *const ::libc::c_char)
     -> *mut pa_proplist;
    pub fn pa_proplist_contains(p: *mut pa_proplist,
                                key: *const ::libc::c_char) -> ::libc::c_int;
    pub fn pa_proplist_clear(p: *mut pa_proplist) -> ();
    pub fn pa_proplist_copy(p: *const pa_proplist) -> *mut pa_proplist;
    pub fn pa_proplist_size(p: *mut pa_proplist) -> ::libc::c_uint;
    pub fn pa_proplist_isempty(p: *mut pa_proplist) -> ::libc::c_int;
    pub fn pa_proplist_equal(a: *mut pa_proplist, b: *mut pa_proplist)
     -> ::libc::c_int;
    pub fn pa_channel_map_init(m: *mut pa_channel_map) -> *mut pa_channel_map;
    pub fn pa_channel_map_init_mono(m: *mut pa_channel_map)
     -> *mut pa_channel_map;
    pub fn pa_channel_map_init_stereo(m: *mut pa_channel_map)
     -> *mut pa_channel_map;
    pub fn pa_channel_map_init_auto(m: *mut pa_channel_map,
                                    channels: ::libc::c_uint,
                                    def: pa_channel_map_def_t)
     -> *mut pa_channel_map;
    pub fn pa_channel_map_init_extend(m: *mut pa_channel_map,
                                      channels: ::libc::c_uint,
                                      def: pa_channel_map_def_t)
     -> *mut pa_channel_map;
    pub fn pa_channel_position_to_string(pos: pa_channel_position_t)
     -> *const ::libc::c_char;
    pub fn pa_channel_position_from_string(s: *const ::libc::c_char)
     -> pa_channel_position_t;
    pub fn pa_channel_position_to_pretty_string(pos: pa_channel_position_t)
     -> *const ::libc::c_char;
    pub fn pa_channel_map_snprint(s: *mut ::libc::c_char, l: size_t,
                                  map: *const pa_channel_map)
     -> *mut ::libc::c_char;
    pub fn pa_channel_map_parse(map: *mut pa_channel_map,
                                s: *const ::libc::c_char)
     -> *mut pa_channel_map;
    pub fn pa_channel_map_equal(a: *const pa_channel_map,
                                b: *const pa_channel_map) -> ::libc::c_int;
    pub fn pa_channel_map_valid(map: *const pa_channel_map) -> ::libc::c_int;
    pub fn pa_channel_map_compatible(map: *const pa_channel_map,
                                     ss: *const pa_sample_spec)
     -> ::libc::c_int;
    pub fn pa_channel_map_superset(a: *const pa_channel_map,
                                   b: *const pa_channel_map) -> ::libc::c_int;
    pub fn pa_channel_map_can_balance(map: *const pa_channel_map)
     -> ::libc::c_int;
    pub fn pa_channel_map_can_fade(map: *const pa_channel_map)
     -> ::libc::c_int;
    pub fn pa_channel_map_to_name(map: *const pa_channel_map)
     -> *const ::libc::c_char;
    pub fn pa_channel_map_to_pretty_name(map: *const pa_channel_map)
     -> *const ::libc::c_char;
    pub fn pa_channel_map_has_position(map: *const pa_channel_map,
                                       p: pa_channel_position_t)
     -> ::libc::c_int;
    pub fn pa_channel_map_mask(map: *const pa_channel_map)
     -> pa_channel_position_mask_t;
    pub fn pa_encoding_to_string(e: pa_encoding_t) -> *const ::libc::c_char;
    pub fn pa_encoding_from_string(encoding: *const ::libc::c_char)
     -> pa_encoding_t;
    pub fn pa_format_info_new() -> *mut pa_format_info;
    pub fn pa_format_info_copy(src: *const pa_format_info)
     -> *mut pa_format_info;
    pub fn pa_format_info_free(f: *mut pa_format_info) -> ();
    pub fn pa_format_info_valid(f: *const pa_format_info) -> ::libc::c_int;
    pub fn pa_format_info_is_pcm(f: *const pa_format_info) -> ::libc::c_int;
    pub fn pa_format_info_is_compatible(first: *const pa_format_info,
                                        second: *const pa_format_info)
     -> ::libc::c_int;
    pub fn pa_format_info_snprint(s: *mut ::libc::c_char, l: size_t,
                                  f: *const pa_format_info)
     -> *mut ::libc::c_char;
    pub fn pa_format_info_from_string(str: *const ::libc::c_char)
     -> *mut pa_format_info;
    pub fn pa_format_info_from_sample_spec(ss: *const pa_sample_spec,
                                           map: *const pa_channel_map)
     -> *mut pa_format_info;
    pub fn pa_format_info_to_sample_spec(f: *const pa_format_info,
                                         ss: *mut pa_sample_spec,
                                         map: *mut pa_channel_map)
     -> ::libc::c_int;
    pub fn pa_format_info_get_prop_type(f: *const pa_format_info,
                                        key: *const ::libc::c_char)
     -> pa_prop_type_t;
    pub fn pa_format_info_get_prop_int(f: *const pa_format_info,
                                       key: *const ::libc::c_char,
                                       v: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pa_format_info_get_prop_int_range(f: *const pa_format_info,
                                             key: *const ::libc::c_char,
                                             min: *mut ::libc::c_int,
                                             max: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pa_format_info_get_prop_int_array(f: *const pa_format_info,
                                             key: *const ::libc::c_char,
                                             values: *mut *mut ::libc::c_int,
                                             n_values: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pa_format_info_get_prop_string(f: *const pa_format_info,
                                          key: *const ::libc::c_char,
                                          v: *mut *mut ::libc::c_char)
     -> ::libc::c_int;
    pub fn pa_format_info_get_prop_string_array(f: *const pa_format_info,
                                                key: *const ::libc::c_char,
                                                values:
                                                    *mut *mut *mut ::libc::c_char,
                                                n_values: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pa_format_info_free_string_array(values: *mut *mut ::libc::c_char,
                                            n_values: ::libc::c_int) -> ();
    pub fn pa_format_info_set_prop_int(f: *mut pa_format_info,
                                       key: *const ::libc::c_char,
                                       value: ::libc::c_int) -> ();
    pub fn pa_format_info_set_prop_int_array(f: *mut pa_format_info,
                                             key: *const ::libc::c_char,
                                             values: *const ::libc::c_int,
                                             n_values: ::libc::c_int) -> ();
    pub fn pa_format_info_set_prop_int_range(f: *mut pa_format_info,
                                             key: *const ::libc::c_char,
                                             min: ::libc::c_int,
                                             max: ::libc::c_int) -> ();
    pub fn pa_format_info_set_prop_string(f: *mut pa_format_info,
                                          key: *const ::libc::c_char,
                                          value: *const ::libc::c_char) -> ();
    pub fn pa_format_info_set_prop_string_array(f: *mut pa_format_info,
                                                key: *const ::libc::c_char,
                                                values:
                                                    *mut *const ::libc::c_char,
                                                n_values: ::libc::c_int)
     -> ();
    pub fn pa_format_info_set_sample_format(f: *mut pa_format_info,
                                            sf: pa_sample_format_t) -> ();
    pub fn pa_format_info_set_rate(f: *mut pa_format_info,
                                   rate: ::libc::c_int) -> ();
    pub fn pa_format_info_set_channels(f: *mut pa_format_info,
                                       channels: ::libc::c_int) -> ();
    pub fn pa_format_info_set_channel_map(f: *mut pa_format_info,
                                          map: *const pa_channel_map) -> ();
    pub fn pa_operation_ref(o: *mut pa_operation) -> *mut pa_operation;
    pub fn pa_operation_unref(o: *mut pa_operation) -> ();
    pub fn pa_operation_cancel(o: *mut pa_operation) -> ();
    pub fn pa_operation_get_state(o: *mut pa_operation)
     -> pa_operation_state_t;
    pub fn pa_operation_set_state_callback(o: *mut pa_operation,
                                           cb: pa_operation_notify_cb_t,
                                           userdata: *mut ::libc::c_void)
     -> ();
    pub fn pa_context_new(mainloop: *mut pa_mainloop_api,
                          name: *const ::libc::c_char) -> *mut pa_context;
    pub fn pa_context_new_with_proplist(mainloop: *mut pa_mainloop_api,
                                        name: *const ::libc::c_char,
                                        proplist: *mut pa_proplist)
     -> *mut pa_context;
    pub fn pa_context_unref(c: *mut pa_context) -> ();
    pub fn pa_context_ref(c: *mut pa_context) -> *mut pa_context;
    pub fn pa_context_set_state_callback(c: *mut pa_context,
                                         cb: pa_context_notify_cb_t,
                                         userdata: *mut ::libc::c_void) -> ();
    pub fn pa_context_set_event_callback(p: *mut pa_context,
                                         cb: pa_context_event_cb_t,
                                         userdata: *mut ::libc::c_void) -> ();
    pub fn pa_context_errno(c: *mut pa_context) -> ::libc::c_int;
    pub fn pa_context_is_pending(c: *mut pa_context) -> ::libc::c_int;
    pub fn pa_context_get_state(c: *mut pa_context) -> pa_context_state_t;
    pub fn pa_context_connect(c: *mut pa_context,
                              server: *const ::libc::c_char,
                              flags: pa_context_flags_t,
                              api: *const pa_spawn_api) -> ::libc::c_int;
    pub fn pa_context_disconnect(c: *mut pa_context) -> ();
    pub fn pa_context_drain(c: *mut pa_context, cb: pa_context_notify_cb_t,
                            userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_exit_daemon(c: *mut pa_context,
                                  cb: pa_context_success_cb_t,
                                  userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_default_sink(c: *mut pa_context,
                                       name: *const ::libc::c_char,
                                       cb: pa_context_success_cb_t,
                                       userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_default_source(c: *mut pa_context,
                                         name: *const ::libc::c_char,
                                         cb: pa_context_success_cb_t,
                                         userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_is_local(c: *mut pa_context) -> ::libc::c_int;
    pub fn pa_context_set_name(c: *mut pa_context,
                               name: *const ::libc::c_char,
                               cb: pa_context_success_cb_t,
                               userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_server(c: *mut pa_context) -> *const ::libc::c_char;
    pub fn pa_context_get_protocol_version(c: *mut pa_context) -> uint32_t;
    pub fn pa_context_get_server_protocol_version(c: *mut pa_context)
     -> uint32_t;
    pub fn pa_context_proplist_update(c: *mut pa_context,
                                      mode: pa_update_mode_t,
                                      p: *mut pa_proplist,
                                      cb: pa_context_success_cb_t,
                                      userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_proplist_remove(c: *mut pa_context,
                                      keys: *const *const ::libc::c_char,
                                      cb: pa_context_success_cb_t,
                                      userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_index(s: *mut pa_context) -> uint32_t;
    pub fn pa_context_rttime_new(c: *mut pa_context, usec: pa_usec_t,
                                 cb: pa_time_event_cb_t,
                                 userdata: *mut ::libc::c_void)
     -> *mut pa_time_event;
    pub fn pa_context_rttime_restart(c: *mut pa_context,
                                     e: *mut pa_time_event, usec: pa_usec_t)
     -> ();
    pub fn pa_context_get_tile_size(c: *mut pa_context,
                                    ss: *const pa_sample_spec) -> size_t;
    pub fn pa_context_load_cookie_from_file(c: *mut pa_context,
                                            cookie_file_path:
                                                *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn pa_cvolume_equal(a: *const pa_cvolume, b: *const pa_cvolume)
     -> ::libc::c_int;
    pub fn pa_cvolume_init(a: *mut pa_cvolume) -> *mut pa_cvolume;
    pub fn pa_cvolume_set(a: *mut pa_cvolume, channels: ::libc::c_uint,
                          v: pa_volume_t) -> *mut pa_cvolume;
    pub fn pa_cvolume_snprint(s: *mut ::libc::c_char, l: size_t,
                              c: *const pa_cvolume) -> *mut ::libc::c_char;
    pub fn pa_sw_cvolume_snprint_dB(s: *mut ::libc::c_char, l: size_t,
                                    c: *const pa_cvolume)
     -> *mut ::libc::c_char;
    pub fn pa_cvolume_snprint_verbose(s: *mut ::libc::c_char, l: size_t,
                                      c: *const pa_cvolume,
                                      map: *const pa_channel_map,
                                      print_dB: ::libc::c_int)
     -> *mut ::libc::c_char;
    pub fn pa_volume_snprint(s: *mut ::libc::c_char, l: size_t,
                             v: pa_volume_t) -> *mut ::libc::c_char;
    pub fn pa_sw_volume_snprint_dB(s: *mut ::libc::c_char, l: size_t,
                                   v: pa_volume_t) -> *mut ::libc::c_char;
    pub fn pa_volume_snprint_verbose(s: *mut ::libc::c_char, l: size_t,
                                     v: pa_volume_t, print_dB: ::libc::c_int)
     -> *mut ::libc::c_char;
    pub fn pa_cvolume_avg(a: *const pa_cvolume) -> pa_volume_t;
    pub fn pa_cvolume_avg_mask(a: *const pa_cvolume,
                               cm: *const pa_channel_map,
                               mask: pa_channel_position_mask_t)
     -> pa_volume_t;
    pub fn pa_cvolume_max(a: *const pa_cvolume) -> pa_volume_t;
    pub fn pa_cvolume_max_mask(a: *const pa_cvolume,
                               cm: *const pa_channel_map,
                               mask: pa_channel_position_mask_t)
     -> pa_volume_t;
    pub fn pa_cvolume_min(a: *const pa_cvolume) -> pa_volume_t;
    pub fn pa_cvolume_min_mask(a: *const pa_cvolume,
                               cm: *const pa_channel_map,
                               mask: pa_channel_position_mask_t)
     -> pa_volume_t;
    pub fn pa_cvolume_valid(v: *const pa_cvolume) -> ::libc::c_int;
    pub fn pa_cvolume_channels_equal_to(a: *const pa_cvolume, v: pa_volume_t)
     -> ::libc::c_int;
    pub fn pa_sw_volume_multiply(a: pa_volume_t, b: pa_volume_t)
     -> pa_volume_t;
    pub fn pa_sw_cvolume_multiply(dest: *mut pa_cvolume, a: *const pa_cvolume,
                                  b: *const pa_cvolume) -> *mut pa_cvolume;
    pub fn pa_sw_cvolume_multiply_scalar(dest: *mut pa_cvolume,
                                         a: *const pa_cvolume, b: pa_volume_t)
     -> *mut pa_cvolume;
    pub fn pa_sw_volume_divide(a: pa_volume_t, b: pa_volume_t) -> pa_volume_t;
    pub fn pa_sw_cvolume_divide(dest: *mut pa_cvolume, a: *const pa_cvolume,
                                b: *const pa_cvolume) -> *mut pa_cvolume;
    pub fn pa_sw_cvolume_divide_scalar(dest: *mut pa_cvolume,
                                       a: *const pa_cvolume, b: pa_volume_t)
     -> *mut pa_cvolume;
    pub fn pa_sw_volume_from_dB(f: ::libc::c_double) -> pa_volume_t;
    pub fn pa_sw_volume_to_dB(v: pa_volume_t) -> ::libc::c_double;
    pub fn pa_sw_volume_from_linear(v: ::libc::c_double) -> pa_volume_t;
    pub fn pa_sw_volume_to_linear(v: pa_volume_t) -> ::libc::c_double;
    pub fn pa_cvolume_remap(v: *mut pa_cvolume, from: *const pa_channel_map,
                            to: *const pa_channel_map) -> *mut pa_cvolume;
    pub fn pa_cvolume_compatible(v: *const pa_cvolume,
                                 ss: *const pa_sample_spec) -> ::libc::c_int;
    pub fn pa_cvolume_compatible_with_channel_map(v: *const pa_cvolume,
                                                  cm: *const pa_channel_map)
     -> ::libc::c_int;
    pub fn pa_cvolume_get_balance(v: *const pa_cvolume,
                                  map: *const pa_channel_map)
     -> ::libc::c_float;
    pub fn pa_cvolume_set_balance(v: *mut pa_cvolume,
                                  map: *const pa_channel_map,
                                  new_balance: ::libc::c_float)
     -> *mut pa_cvolume;
    pub fn pa_cvolume_get_fade(v: *const pa_cvolume,
                               map: *const pa_channel_map) -> ::libc::c_float;
    pub fn pa_cvolume_set_fade(v: *mut pa_cvolume, map: *const pa_channel_map,
                               new_fade: ::libc::c_float) -> *mut pa_cvolume;
    pub fn pa_cvolume_scale(v: *mut pa_cvolume, max: pa_volume_t)
     -> *mut pa_cvolume;
    pub fn pa_cvolume_scale_mask(v: *mut pa_cvolume, max: pa_volume_t,
                                 cm: *mut pa_channel_map,
                                 mask: pa_channel_position_mask_t)
     -> *mut pa_cvolume;
    pub fn pa_cvolume_set_position(cv: *mut pa_cvolume,
                                   map: *const pa_channel_map,
                                   t: pa_channel_position_t, v: pa_volume_t)
     -> *mut pa_cvolume;
    pub fn pa_cvolume_get_position(cv: *mut pa_cvolume,
                                   map: *const pa_channel_map,
                                   t: pa_channel_position_t) -> pa_volume_t;
    pub fn pa_cvolume_merge(dest: *mut pa_cvolume, a: *const pa_cvolume,
                            b: *const pa_cvolume) -> *mut pa_cvolume;
    pub fn pa_cvolume_inc_clamp(v: *mut pa_cvolume, inc: pa_volume_t,
                                limit: pa_volume_t) -> *mut pa_cvolume;
    pub fn pa_cvolume_inc(v: *mut pa_cvolume, inc: pa_volume_t)
     -> *mut pa_cvolume;
    pub fn pa_cvolume_dec(v: *mut pa_cvolume, dec: pa_volume_t)
     -> *mut pa_cvolume;
    pub fn pa_stream_new(c: *mut pa_context, name: *const ::libc::c_char,
                         ss: *const pa_sample_spec,
                         map: *const pa_channel_map) -> *mut pa_stream;
    pub fn pa_stream_new_with_proplist(c: *mut pa_context,
                                       name: *const ::libc::c_char,
                                       ss: *const pa_sample_spec,
                                       map: *const pa_channel_map,
                                       p: *mut pa_proplist) -> *mut pa_stream;
    pub fn pa_stream_new_extended(c: *mut pa_context,
                                  name: *const ::libc::c_char,
                                  formats: *const *mut pa_format_info,
                                  n_formats: ::libc::c_uint,
                                  p: *mut pa_proplist) -> *mut pa_stream;
    pub fn pa_stream_unref(s: *mut pa_stream) -> ();
    pub fn pa_stream_ref(s: *mut pa_stream) -> *mut pa_stream;
    pub fn pa_stream_get_state(p: *mut pa_stream) -> pa_stream_state_t;
    pub fn pa_stream_get_context(p: *mut pa_stream) -> *mut pa_context;
    pub fn pa_stream_get_index(s: *mut pa_stream) -> uint32_t;
    pub fn pa_stream_get_device_index(s: *mut pa_stream) -> uint32_t;
    pub fn pa_stream_get_device_name(s: *mut pa_stream)
     -> *const ::libc::c_char;
    pub fn pa_stream_is_suspended(s: *mut pa_stream) -> ::libc::c_int;
    pub fn pa_stream_is_corked(s: *mut pa_stream) -> ::libc::c_int;
    pub fn pa_stream_connect_playback(s: *mut pa_stream,
                                      dev: *const ::libc::c_char,
                                      attr: *const pa_buffer_attr,
                                      flags: pa_stream_flags_t,
                                      volume: *const pa_cvolume,
                                      sync_stream: *mut pa_stream)
     -> ::libc::c_int;
    pub fn pa_stream_connect_record(s: *mut pa_stream,
                                    dev: *const ::libc::c_char,
                                    attr: *const pa_buffer_attr,
                                    flags: pa_stream_flags_t)
     -> ::libc::c_int;
    pub fn pa_stream_disconnect(s: *mut pa_stream) -> ::libc::c_int;
    pub fn pa_stream_begin_write(p: *mut pa_stream,
                                 data: *mut *mut ::libc::c_void,
                                 nbytes: *mut size_t) -> ::libc::c_int;
    pub fn pa_stream_cancel_write(p: *mut pa_stream) -> ::libc::c_int;
    pub fn pa_stream_write(p: *mut pa_stream, data: *const ::libc::c_void,
                           nbytes: size_t, free_cb: pa_free_cb_t,
                           offset: int64_t, seek: pa_seek_mode_t)
     -> ::libc::c_int;
    pub fn pa_stream_write_ext_free(p: *mut pa_stream,
                                    data: *const ::libc::c_void,
                                    nbytes: size_t, free_cb: pa_free_cb_t,
                                    free_cb_data: *mut ::libc::c_void,
                                    offset: int64_t, seek: pa_seek_mode_t)
     -> ::libc::c_int;
    pub fn pa_stream_peek(p: *mut pa_stream, data: *mut *const ::libc::c_void,
                          nbytes: *mut size_t) -> ::libc::c_int;
    pub fn pa_stream_drop(p: *mut pa_stream) -> ::libc::c_int;
    pub fn pa_stream_writable_size(p: *mut pa_stream) -> size_t;
    pub fn pa_stream_readable_size(p: *mut pa_stream) -> size_t;
    pub fn pa_stream_drain(s: *mut pa_stream, cb: pa_stream_success_cb_t,
                           userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_stream_update_timing_info(p: *mut pa_stream,
                                        cb: pa_stream_success_cb_t,
                                        userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_stream_set_state_callback(s: *mut pa_stream,
                                        cb: pa_stream_notify_cb_t,
                                        userdata: *mut ::libc::c_void) -> ();
    pub fn pa_stream_set_write_callback(p: *mut pa_stream,
                                        cb: pa_stream_request_cb_t,
                                        userdata: *mut ::libc::c_void) -> ();
    pub fn pa_stream_set_read_callback(p: *mut pa_stream,
                                       cb: pa_stream_request_cb_t,
                                       userdata: *mut ::libc::c_void) -> ();
    pub fn pa_stream_set_overflow_callback(p: *mut pa_stream,
                                           cb: pa_stream_notify_cb_t,
                                           userdata: *mut ::libc::c_void)
     -> ();
    pub fn pa_stream_get_underflow_index(p: *mut pa_stream) -> int64_t;
    pub fn pa_stream_set_underflow_callback(p: *mut pa_stream,
                                            cb: pa_stream_notify_cb_t,
                                            userdata: *mut ::libc::c_void)
     -> ();
    pub fn pa_stream_set_started_callback(p: *mut pa_stream,
                                          cb: pa_stream_notify_cb_t,
                                          userdata: *mut ::libc::c_void)
     -> ();
    pub fn pa_stream_set_latency_update_callback(p: *mut pa_stream,
                                                 cb: pa_stream_notify_cb_t,
                                                 userdata:
                                                     *mut ::libc::c_void)
     -> ();
    pub fn pa_stream_set_moved_callback(p: *mut pa_stream,
                                        cb: pa_stream_notify_cb_t,
                                        userdata: *mut ::libc::c_void) -> ();
    pub fn pa_stream_set_suspended_callback(p: *mut pa_stream,
                                            cb: pa_stream_notify_cb_t,
                                            userdata: *mut ::libc::c_void)
     -> ();
    pub fn pa_stream_set_event_callback(p: *mut pa_stream,
                                        cb: pa_stream_event_cb_t,
                                        userdata: *mut ::libc::c_void) -> ();
    pub fn pa_stream_set_buffer_attr_callback(p: *mut pa_stream,
                                              cb: pa_stream_notify_cb_t,
                                              userdata: *mut ::libc::c_void)
     -> ();
    pub fn pa_stream_cork(s: *mut pa_stream, b: ::libc::c_int,
                          cb: pa_stream_success_cb_t,
                          userdata: *mut ::libc::c_void) -> *mut pa_operation;
    pub fn pa_stream_flush(s: *mut pa_stream, cb: pa_stream_success_cb_t,
                           userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_stream_prebuf(s: *mut pa_stream, cb: pa_stream_success_cb_t,
                            userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_stream_trigger(s: *mut pa_stream, cb: pa_stream_success_cb_t,
                             userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_stream_set_name(s: *mut pa_stream, name: *const ::libc::c_char,
                              cb: pa_stream_success_cb_t,
                              userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_stream_get_time(s: *mut pa_stream, r_usec: *mut pa_usec_t)
     -> ::libc::c_int;
    pub fn pa_stream_get_latency(s: *mut pa_stream, r_usec: *mut pa_usec_t,
                                 negative: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pa_stream_get_timing_info(s: *mut pa_stream)
     -> *const pa_timing_info;
    pub fn pa_stream_get_sample_spec(s: *mut pa_stream)
     -> *const pa_sample_spec;
    pub fn pa_stream_get_channel_map(s: *mut pa_stream)
     -> *const pa_channel_map;
    pub fn pa_stream_get_format_info(s: *mut pa_stream)
     -> *const pa_format_info;
    pub fn pa_stream_get_buffer_attr(s: *mut pa_stream)
     -> *const pa_buffer_attr;
    pub fn pa_stream_set_buffer_attr(s: *mut pa_stream,
                                     attr: *const pa_buffer_attr,
                                     cb: pa_stream_success_cb_t,
                                     userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_stream_update_sample_rate(s: *mut pa_stream, rate: uint32_t,
                                        cb: pa_stream_success_cb_t,
                                        userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_stream_proplist_update(s: *mut pa_stream,
                                     mode: pa_update_mode_t,
                                     p: *mut pa_proplist,
                                     cb: pa_stream_success_cb_t,
                                     userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_stream_proplist_remove(s: *mut pa_stream,
                                     keys: *const *const ::libc::c_char,
                                     cb: pa_stream_success_cb_t,
                                     userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_stream_set_monitor_stream(s: *mut pa_stream,
                                        sink_input_idx: uint32_t)
     -> ::libc::c_int;
    pub fn pa_stream_get_monitor_stream(s: *mut pa_stream) -> uint32_t;
    pub fn pa_context_get_sink_info_by_name(c: *mut pa_context,
                                            name: *const ::libc::c_char,
                                            cb: pa_sink_info_cb_t,
                                            userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_sink_info_by_index(c: *mut pa_context,
                                             idx: uint32_t,
                                             cb: pa_sink_info_cb_t,
                                             userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_sink_info_list(c: *mut pa_context,
                                         cb: pa_sink_info_cb_t,
                                         userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_sink_volume_by_index(c: *mut pa_context,
                                               idx: uint32_t,
                                               volume: *const pa_cvolume,
                                               cb: pa_context_success_cb_t,
                                               userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_sink_volume_by_name(c: *mut pa_context,
                                              name: *const ::libc::c_char,
                                              volume: *const pa_cvolume,
                                              cb: pa_context_success_cb_t,
                                              userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_sink_mute_by_index(c: *mut pa_context,
                                             idx: uint32_t,
                                             mute: ::libc::c_int,
                                             cb: pa_context_success_cb_t,
                                             userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_sink_mute_by_name(c: *mut pa_context,
                                            name: *const ::libc::c_char,
                                            mute: ::libc::c_int,
                                            cb: pa_context_success_cb_t,
                                            userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_suspend_sink_by_name(c: *mut pa_context,
                                           sink_name: *const ::libc::c_char,
                                           suspend: ::libc::c_int,
                                           cb: pa_context_success_cb_t,
                                           userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_suspend_sink_by_index(c: *mut pa_context, idx: uint32_t,
                                            suspend: ::libc::c_int,
                                            cb: pa_context_success_cb_t,
                                            userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_sink_port_by_index(c: *mut pa_context,
                                             idx: uint32_t,
                                             port: *const ::libc::c_char,
                                             cb: pa_context_success_cb_t,
                                             userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_sink_port_by_name(c: *mut pa_context,
                                            name: *const ::libc::c_char,
                                            port: *const ::libc::c_char,
                                            cb: pa_context_success_cb_t,
                                            userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_source_info_by_name(c: *mut pa_context,
                                              name: *const ::libc::c_char,
                                              cb: pa_source_info_cb_t,
                                              userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_source_info_by_index(c: *mut pa_context,
                                               idx: uint32_t,
                                               cb: pa_source_info_cb_t,
                                               userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_source_info_list(c: *mut pa_context,
                                           cb: pa_source_info_cb_t,
                                           userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_source_volume_by_index(c: *mut pa_context,
                                                 idx: uint32_t,
                                                 volume: *const pa_cvolume,
                                                 cb: pa_context_success_cb_t,
                                                 userdata:
                                                     *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_source_volume_by_name(c: *mut pa_context,
                                                name: *const ::libc::c_char,
                                                volume: *const pa_cvolume,
                                                cb: pa_context_success_cb_t,
                                                userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_source_mute_by_index(c: *mut pa_context,
                                               idx: uint32_t,
                                               mute: ::libc::c_int,
                                               cb: pa_context_success_cb_t,
                                               userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_source_mute_by_name(c: *mut pa_context,
                                              name: *const ::libc::c_char,
                                              mute: ::libc::c_int,
                                              cb: pa_context_success_cb_t,
                                              userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_suspend_source_by_name(c: *mut pa_context,
                                             source_name:
                                                 *const ::libc::c_char,
                                             suspend: ::libc::c_int,
                                             cb: pa_context_success_cb_t,
                                             userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_suspend_source_by_index(c: *mut pa_context,
                                              idx: uint32_t,
                                              suspend: ::libc::c_int,
                                              cb: pa_context_success_cb_t,
                                              userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_source_port_by_index(c: *mut pa_context,
                                               idx: uint32_t,
                                               port: *const ::libc::c_char,
                                               cb: pa_context_success_cb_t,
                                               userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_source_port_by_name(c: *mut pa_context,
                                              name: *const ::libc::c_char,
                                              port: *const ::libc::c_char,
                                              cb: pa_context_success_cb_t,
                                              userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_server_info(c: *mut pa_context,
                                      cb: pa_server_info_cb_t,
                                      userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_module_info(c: *mut pa_context, idx: uint32_t,
                                      cb: pa_module_info_cb_t,
                                      userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_module_info_list(c: *mut pa_context,
                                           cb: pa_module_info_cb_t,
                                           userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_load_module(c: *mut pa_context,
                                  name: *const ::libc::c_char,
                                  argument: *const ::libc::c_char,
                                  cb: pa_context_index_cb_t,
                                  userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_unload_module(c: *mut pa_context, idx: uint32_t,
                                    cb: pa_context_success_cb_t,
                                    userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_client_info(c: *mut pa_context, idx: uint32_t,
                                      cb: pa_client_info_cb_t,
                                      userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_client_info_list(c: *mut pa_context,
                                           cb: pa_client_info_cb_t,
                                           userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_kill_client(c: *mut pa_context, idx: uint32_t,
                                  cb: pa_context_success_cb_t,
                                  userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_card_info_by_index(c: *mut pa_context,
                                             idx: uint32_t,
                                             cb: pa_card_info_cb_t,
                                             userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_card_info_by_name(c: *mut pa_context,
                                            name: *const ::libc::c_char,
                                            cb: pa_card_info_cb_t,
                                            userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_card_info_list(c: *mut pa_context,
                                         cb: pa_card_info_cb_t,
                                         userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_card_profile_by_index(c: *mut pa_context,
                                                idx: uint32_t,
                                                profile:
                                                    *const ::libc::c_char,
                                                cb: pa_context_success_cb_t,
                                                userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_card_profile_by_name(c: *mut pa_context,
                                               name: *const ::libc::c_char,
                                               profile: *const ::libc::c_char,
                                               cb: pa_context_success_cb_t,
                                               userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_port_latency_offset(c: *mut pa_context,
                                              card_name:
                                                  *const ::libc::c_char,
                                              port_name:
                                                  *const ::libc::c_char,
                                              offset: int64_t,
                                              cb: pa_context_success_cb_t,
                                              userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_sink_input_info(c: *mut pa_context, idx: uint32_t,
                                          cb: pa_sink_input_info_cb_t,
                                          userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_sink_input_info_list(c: *mut pa_context,
                                               cb: pa_sink_input_info_cb_t,
                                               userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_move_sink_input_by_name(c: *mut pa_context,
                                              idx: uint32_t,
                                              sink_name:
                                                  *const ::libc::c_char,
                                              cb: pa_context_success_cb_t,
                                              userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_move_sink_input_by_index(c: *mut pa_context,
                                               idx: uint32_t,
                                               sink_idx: uint32_t,
                                               cb: pa_context_success_cb_t,
                                               userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_sink_input_volume(c: *mut pa_context, idx: uint32_t,
                                            volume: *const pa_cvolume,
                                            cb: pa_context_success_cb_t,
                                            userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_sink_input_mute(c: *mut pa_context, idx: uint32_t,
                                          mute: ::libc::c_int,
                                          cb: pa_context_success_cb_t,
                                          userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_kill_sink_input(c: *mut pa_context, idx: uint32_t,
                                      cb: pa_context_success_cb_t,
                                      userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_source_output_info(c: *mut pa_context,
                                             idx: uint32_t,
                                             cb: pa_source_output_info_cb_t,
                                             userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_source_output_info_list(c: *mut pa_context,
                                                  cb:
                                                      pa_source_output_info_cb_t,
                                                  userdata:
                                                      *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_move_source_output_by_name(c: *mut pa_context,
                                                 idx: uint32_t,
                                                 source_name:
                                                     *const ::libc::c_char,
                                                 cb: pa_context_success_cb_t,
                                                 userdata:
                                                     *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_move_source_output_by_index(c: *mut pa_context,
                                                  idx: uint32_t,
                                                  source_idx: uint32_t,
                                                  cb: pa_context_success_cb_t,
                                                  userdata:
                                                      *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_source_output_volume(c: *mut pa_context,
                                               idx: uint32_t,
                                               volume: *const pa_cvolume,
                                               cb: pa_context_success_cb_t,
                                               userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_source_output_mute(c: *mut pa_context,
                                             idx: uint32_t,
                                             mute: ::libc::c_int,
                                             cb: pa_context_success_cb_t,
                                             userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_kill_source_output(c: *mut pa_context, idx: uint32_t,
                                         cb: pa_context_success_cb_t,
                                         userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_stat(c: *mut pa_context, cb: pa_stat_info_cb_t,
                           userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_sample_info_by_name(c: *mut pa_context,
                                              name: *const ::libc::c_char,
                                              cb: pa_sample_info_cb_t,
                                              userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_sample_info_by_index(c: *mut pa_context,
                                               idx: uint32_t,
                                               cb: pa_sample_info_cb_t,
                                               userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_sample_info_list(c: *mut pa_context,
                                           cb: pa_sample_info_cb_t,
                                           userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_autoload_info_by_name(c: *mut pa_context,
                                                name: *const ::libc::c_char,
                                                _type: pa_autoload_type_t,
                                                cb: pa_autoload_info_cb_t,
                                                userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_autoload_info_by_index(c: *mut pa_context,
                                                 idx: uint32_t,
                                                 cb: pa_autoload_info_cb_t,
                                                 userdata:
                                                     *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_get_autoload_info_list(c: *mut pa_context,
                                             cb: pa_autoload_info_cb_t,
                                             userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_add_autoload(c: *mut pa_context,
                                   name: *const ::libc::c_char,
                                   _type: pa_autoload_type_t,
                                   module: *const ::libc::c_char,
                                   argument: *const ::libc::c_char,
                                   arg1: pa_context_index_cb_t,
                                   userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_remove_autoload_by_name(c: *mut pa_context,
                                              name: *const ::libc::c_char,
                                              _type: pa_autoload_type_t,
                                              cb: pa_context_success_cb_t,
                                              userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_remove_autoload_by_index(c: *mut pa_context,
                                               idx: uint32_t,
                                               cb: pa_context_success_cb_t,
                                               userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_subscribe(c: *mut pa_context, m: pa_subscription_mask_t,
                                cb: pa_context_success_cb_t,
                                userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_set_subscribe_callback(c: *mut pa_context,
                                             cb: pa_context_subscribe_cb_t,
                                             userdata: *mut ::libc::c_void)
     -> ();
    pub fn pa_stream_connect_upload(s: *mut pa_stream, length: size_t)
     -> ::libc::c_int;
    pub fn pa_stream_finish_upload(s: *mut pa_stream) -> ::libc::c_int;
    pub fn pa_context_remove_sample(c: *mut pa_context,
                                    name: *const ::libc::c_char,
                                    cb: pa_context_success_cb_t,
                                    userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_play_sample(c: *mut pa_context,
                                  name: *const ::libc::c_char,
                                  dev: *const ::libc::c_char,
                                  volume: pa_volume_t,
                                  cb: pa_context_success_cb_t,
                                  userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_context_play_sample_with_proplist(c: *mut pa_context,
                                                name: *const ::libc::c_char,
                                                dev: *const ::libc::c_char,
                                                volume: pa_volume_t,
                                                proplist: *mut pa_proplist,
                                                cb:
                                                    pa_context_play_sample_cb_t,
                                                userdata: *mut ::libc::c_void)
     -> *mut pa_operation;
    pub fn pa_strerror(error: ::libc::c_int) -> *const ::libc::c_char;
    pub fn pa_xmalloc(l: size_t) -> *mut ::libc::c_void;
    pub fn pa_xmalloc0(l: size_t) -> *mut ::libc::c_void;
    pub fn pa_xrealloc(ptr: *mut ::libc::c_void, size: size_t)
     -> *mut ::libc::c_void;
    pub fn pa_xfree(p: *mut ::libc::c_void) -> ();
    pub fn pa_xstrdup(s: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn pa_xstrndup(s: *const ::libc::c_char, l: size_t)
     -> *mut ::libc::c_char;
    pub fn pa_xmemdup(p: *const ::libc::c_void, l: size_t)
     -> *mut ::libc::c_void;
    pub fn pa_utf8_valid(str: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn pa_ascii_valid(str: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn pa_utf8_filter(str: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn pa_ascii_filter(str: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn pa_utf8_to_locale(str: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn pa_locale_to_utf8(str: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn pa_threaded_mainloop_new() -> *mut pa_threaded_mainloop;
    pub fn pa_threaded_mainloop_free(m: *mut pa_threaded_mainloop) -> ();
    pub fn pa_threaded_mainloop_start(m: *mut pa_threaded_mainloop)
     -> ::libc::c_int;
    pub fn pa_threaded_mainloop_stop(m: *mut pa_threaded_mainloop) -> ();
    pub fn pa_threaded_mainloop_lock(m: *mut pa_threaded_mainloop) -> ();
    pub fn pa_threaded_mainloop_unlock(m: *mut pa_threaded_mainloop) -> ();
    pub fn pa_threaded_mainloop_wait(m: *mut pa_threaded_mainloop) -> ();
    pub fn pa_threaded_mainloop_signal(m: *mut pa_threaded_mainloop,
                                       wait_for_accept: ::libc::c_int) -> ();
    pub fn pa_threaded_mainloop_accept(m: *mut pa_threaded_mainloop) -> ();
    pub fn pa_threaded_mainloop_get_retval(m: *mut pa_threaded_mainloop)
     -> ::libc::c_int;
    pub fn pa_threaded_mainloop_get_api(m: *mut pa_threaded_mainloop)
     -> *mut pa_mainloop_api;
    pub fn pa_threaded_mainloop_in_thread(m: *mut pa_threaded_mainloop)
     -> ::libc::c_int;
    pub fn pa_threaded_mainloop_set_name(m: *mut pa_threaded_mainloop,
                                         name: *const ::libc::c_char) -> ();
    pub fn pa_mainloop_new() -> *mut pa_mainloop;
    pub fn pa_mainloop_free(m: *mut pa_mainloop) -> ();
    pub fn pa_mainloop_prepare(m: *mut pa_mainloop, timeout: ::libc::c_int)
     -> ::libc::c_int;
    pub fn pa_mainloop_poll(m: *mut pa_mainloop) -> ::libc::c_int;
    pub fn pa_mainloop_dispatch(m: *mut pa_mainloop) -> ::libc::c_int;
    pub fn pa_mainloop_get_retval(m: *mut pa_mainloop) -> ::libc::c_int;
    pub fn pa_mainloop_iterate(m: *mut pa_mainloop, block: ::libc::c_int,
                               retval: *mut ::libc::c_int) -> ::libc::c_int;
    pub fn pa_mainloop_run(m: *mut pa_mainloop, retval: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pa_mainloop_get_api(m: *mut pa_mainloop) -> *mut pa_mainloop_api;
    pub fn pa_mainloop_quit(m: *mut pa_mainloop, retval: ::libc::c_int) -> ();
    pub fn pa_mainloop_wakeup(m: *mut pa_mainloop) -> ();
    pub fn pa_mainloop_set_poll_func(m: *mut pa_mainloop,
                                     poll_func: pa_poll_func,
                                     userdata: *mut ::libc::c_void) -> ();
    pub fn pa_signal_init(api: *mut pa_mainloop_api) -> ::libc::c_int;
    pub fn pa_signal_done() -> ();
    pub fn pa_signal_new(sig: ::libc::c_int, callback: pa_signal_cb_t,
                         userdata: *mut ::libc::c_void)
     -> *mut pa_signal_event;
    pub fn pa_signal_free(e: *mut pa_signal_event) -> ();
    pub fn pa_signal_set_destroy(e: *mut pa_signal_event,
                                 callback: pa_signal_destroy_cb_t) -> ();
    pub fn pa_get_user_name(s: *mut ::libc::c_char, l: size_t)
     -> *mut ::libc::c_char;
    pub fn pa_get_host_name(s: *mut ::libc::c_char, l: size_t)
     -> *mut ::libc::c_char;
    pub fn pa_get_fqdn(s: *mut ::libc::c_char, l: size_t)
     -> *mut ::libc::c_char;
    pub fn pa_get_home_dir(s: *mut ::libc::c_char, l: size_t)
     -> *mut ::libc::c_char;
    pub fn pa_get_binary_name(s: *mut ::libc::c_char, l: size_t)
     -> *mut ::libc::c_char;
    pub fn pa_path_get_filename(p: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn pa_msleep(t: ::libc::c_ulong) -> ::libc::c_int;
    pub fn pa_gettimeofday(tv: *mut Struct_timeval) -> *mut Struct_timeval;
    pub fn pa_timeval_diff(a: *const Struct_timeval, b: *const Struct_timeval)
     -> pa_usec_t;
    pub fn pa_timeval_cmp(a: *const Struct_timeval, b: *const Struct_timeval)
     -> ::libc::c_int;
    pub fn pa_timeval_age(tv: *const Struct_timeval) -> pa_usec_t;
    pub fn pa_timeval_add(tv: *mut Struct_timeval, v: pa_usec_t)
     -> *mut Struct_timeval;
    pub fn pa_timeval_sub(tv: *mut Struct_timeval, v: pa_usec_t)
     -> *mut Struct_timeval;
    pub fn pa_timeval_store(tv: *mut Struct_timeval, v: pa_usec_t)
     -> *mut Struct_timeval;
    pub fn pa_timeval_load(tv: *const Struct_timeval) -> pa_usec_t;
    pub fn pa_rtclock_now() -> pa_usec_t;
}
#[link(name = "pulse-simple")]
extern "C" {
    pub fn pa_simple_new(server: *const ::libc::c_char,
                         name: *const ::libc::c_char,
                         dir: pa_stream_direction_t,
                         dev: *const ::libc::c_char,
                         stream_name: *const ::libc::c_char,
                         ss: *const pa_sample_spec,
                         map: *const pa_channel_map,
                         attr: *const pa_buffer_attr,
                         error: *mut ::libc::c_int) -> *mut pa_simple;
    pub fn pa_simple_free(s: *mut pa_simple) -> ();
    pub fn pa_simple_write(s: *mut pa_simple, data: *const ::libc::c_void,
                           bytes: size_t, error: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pa_simple_drain(s: *mut pa_simple, error: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pa_simple_read(s: *mut pa_simple, data: *mut ::libc::c_void,
                          bytes: size_t, error: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn pa_simple_get_latency(s: *mut pa_simple, error: *mut ::libc::c_int)
     -> pa_usec_t;
    pub fn pa_simple_flush(s: *mut pa_simple, error: *mut ::libc::c_int)
     -> ::libc::c_int;
}
